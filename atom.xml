<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>研友.PinkPather_</title>
  
  
  <link href="https://blog.cilicili.xyz/atom.xml" rel="self"/>
  
  <link href="https://blog.cilicili.xyz/"/>
  <updated>2022-07-17T07:43:27.703Z</updated>
  <id>https://blog.cilicili.xyz/</id>
  
  <author>
    <name>研友.PinkPather_</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CodeTop字节跳动前端算法（一）</title>
    <link href="https://blog.cilicili.xyz/posts/4a17b158.html"/>
    <id>https://blog.cilicili.xyz/posts/4a17b158.html</id>
    <published>2022-07-14T16:00:00.000Z</published>
    <updated>2022-07-17T07:43:27.703Z</updated>
    
    <content type="html"><![CDATA[<h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h3><p>难度：中等频度：41</p><p>题目：给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;abc&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure><p>1.思路：利用 <strong>数组</strong> 解法</p><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.<span class="property">length</span>;i++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(arr.<span class="title function_">includes</span>(s[i]))&#123;</span><br><span class="line">        arr.<span class="title function_">splice</span>(<span class="number">0</span>,arr.<span class="title function_">indexOf</span>(s[i])+<span class="number">1</span>)<span class="comment">//如果重复了就删除前面所有的字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    arr.<span class="title function_">push</span>(s[i])<span class="comment">//如果不重复就添加</span></span><br><span class="line">    res = <span class="title class_">Math</span>.<span class="title function_">max</span>(res,arr.<span class="property">length</span>)<span class="comment">//记录最长的长度</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res<span class="comment">//返回长度结果  利用数组还可以将完整的子串返回出来</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行用时：72ms </p><p>2.思路：<strong>滑动窗口法</strong></p><ul><li>用双指针维护一个滑动窗口，用来剪切子串。</li><li>不断移动右指针，直到遇到重复字符的时候把左指针移到前面的重复字符的下一位。</li><li>移动指针过程中，记录窗口长度的最大值即为答案。</li></ul><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">s</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> l=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> map=<span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> r=<span class="number">0</span>;r&lt;s.<span class="property">length</span>;r++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">has</span>(s[r])&amp;&amp;map.<span class="title function_">get</span>(s[r])&gt;=l)&#123;</span><br><span class="line">            l=map.<span class="title function_">get</span>(s[r])+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//console.log(s.slice(l,r+1))</span></span><br><span class="line">        res=<span class="title class_">Math</span>.<span class="title function_">max</span>(res,r-l+<span class="number">1</span>);</span><br><span class="line">        map.<span class="title function_">set</span>(s[r],r);</span><br><span class="line">        <span class="comment">//console.log(&quot;map&quot;,map)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lengthOfLongestSubstring</span>(<span class="string">&quot;abbcdea&quot;</span>))</span><br></pre></td></tr></table></figure><p>执行用时：76ms</p><h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h3><p>难度：简单频度：26</p><p>题目：给你两个按 <strong>非递减顺序</strong> 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 <strong>合并</strong> nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p><strong>注意</strong>：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span>, nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>], n = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">解释：需要合并 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 和 [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>] 。</span><br><span class="line">合并结果是 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>] ，其中前两个为 nums1 中的元素。</span><br></pre></td></tr></table></figure><p>代码：</p><p>1.简单版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) &#123;</span><br><span class="line">    <span class="comment">// 将splice将nums2的值放到nums1的后面</span></span><br><span class="line">    <span class="comment">// 从m位置开始删除n个（nums2的长度）元素，然后将nums2添加到最后</span></span><br><span class="line">    nums1.<span class="title function_">splice</span>(m,n,...nums2);</span><br><span class="line">    <span class="comment">// 将nums1进行排序,修改的是原来的数组，所以不需要返回</span></span><br><span class="line">    nums1.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>(a-b)); <span class="comment">// sort((a,b)=&gt;(a-b))冒泡排序</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.<a href="%5Bhttps://leetcode-cn.com/problems/merge-sorted-array/solution/ni-xiang-shuang-zhi-zhen-he-bing-liang-g-ucgj/%5D()">逆双向指针</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置三个指针，分别指向nums1和nums2的数字部分的尾部 + nums1数组的尾部</span></span><br><span class="line">    <span class="keyword">var</span> i = m-<span class="number">1</span>,</span><br><span class="line">        j = n-<span class="number">1</span>,</span><br><span class="line">        k = m+n-<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 必须把所有的条件判断都写到一起，这样满足一个条件就会结束本次循环。不会继续往下执行。</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 其中一个数组不为空，就可以进行下面的循环</span></span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123; </span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// nums1为空的情况,将nums2的所有值放到nums1中</span></span><br><span class="line">            nums1[k--] = nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// nums2为空的情况,将nums1的所有值放到nums1中</span></span><br><span class="line">            nums1[k--] = nums1[i--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两者均不空的时候</span></span><br><span class="line">        <span class="comment">// 如果数组2中的数字大，就放到数组1的末尾.并且元素需要移动，所以需要自减操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">            nums1[k--] = nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 数组1中的数字大，就移动数组1中的数字到数组1的末尾</span></span><br><span class="line">            nums1[k--] = nums1[i--];   </span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="比较版本号"><a href="#比较版本号" class="headerlink" title="比较版本号"></a>比较版本号</h3><p>难度：中等频度：22</p><p>题目：给你两个版本号 <code>version1</code> 和 <code>version2</code> ，请你比较它们。</p><p>版本号由一个或多个修订号组成，各修订号由一个 <code>&#39;.&#39;</code> 连接。每个修订号由 <strong>多位数字</strong> 组成，可能包含 <strong>前导零</strong> 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，<code>2.5.33</code> 和 <code>0.1</code> 都是有效的版本号。</p><p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 <strong>忽略任何前导零后的整数值</strong> 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</p><p>返回规则如下：</p><p>如果 version1 &gt; version2 返回 1，<br>如果 version1 &lt; version2 返回 -1，<br>除此之外返回 0。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：version1 = <span class="string">&quot;1.01&quot;</span>, version2 = <span class="string">&quot;1.001&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：忽略前导零，<span class="string">&quot;01&quot;</span> 和 <span class="string">&quot;001&quot;</span> 都表示相同的整数 <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compareVersion = <span class="keyword">function</span>(<span class="params">version1, version2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> a = version1.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> b = version2.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> maxLength = <span class="title class_">Math</span>.<span class="title function_">max</span>(a.<span class="property">length</span>, b.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxLength; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> cur = a[i] || <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> next = b[i] || <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[i] === b[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">parseInt</span>(cur) &gt; <span class="built_in">parseInt</span>(next)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">parseInt</span>(cur) &lt; <span class="built_in">parseInt</span>(next)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h3><p>难度：简单频度：21</p><p>题目：给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <code>根节点到叶子节点</code> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> </p><p>示例：</p><p><img src= "/img/loading.gif" data-lazy-src="./images/loading.gif" data-original="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="literal">null</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">1</span>], targetSum = <span class="number">22</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：等于目标和的根节点到叶节点路径如上图所示。</span><br></pre></td></tr></table></figure><p>思路：使用深度优先遍历的方式，递归左右子树，不断让sum减去当前节点的值。左右子树有一个返回true就找到了一条这样的路径<br>复杂度：时间复杂度O(n)，n是节点个数，每个节点遍历一次。空间复杂度O(n)，取决于递归栈空间，最坏的情况下是O(n)</p><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasPathSum = <span class="keyword">function</span>(<span class="params">root, sum</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 递归终止条件</span></span><br><span class="line">    sum-=root.<span class="property">val</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">left</span> === <span class="literal">null</span> &amp;&amp; root.<span class="property">right</span> === <span class="literal">null</span>) &#123; <span class="comment">// 遍历到叶子结点</span></span><br><span class="line">        <span class="keyword">return</span> sum === <span class="number">0</span>; <span class="comment">// sum正好减少到了0 返回ture 否则返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归左右子树，有一个返回true就找到了一条这样的路径</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">hasPathSum</span>(root.<span class="property">left</span>, sum) || <span class="title function_">hasPathSum</span>(root.<span class="property">right</span>, sum);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h3><p>难度：简单频度：20</p><p>题目：给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>​1.左括号必须用相同类型的右括号闭合。<br>​2.左括号必须以正确的顺序闭合。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;()&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> len=s.<span class="property">length</span>/<span class="number">2</span>; <span class="comment">// 如果字符串是奇数，则括号必定无法匹配</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        s= s.<span class="title function_">replace</span>(<span class="string">&quot;[]&quot;</span>,<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        s= s.<span class="title function_">replace</span>(<span class="string">&quot;()&quot;</span>,<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        s= s.<span class="title function_">replace</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="property">length</span>&gt;<span class="number">0</span> ?<span class="attr">false</span>:<span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最大的子数组合"><a href="#最大的子数组合" class="headerlink" title="最大的子数组合"></a>最大的子数组合</h3><p>难度：简单频度：20</p><p>题目：给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：连续子数组 [<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 的和最大，为 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="comment">// 0 为无，0 在累加类的算法计算中将不会对结果产生任何影响，所以初始化 sum 为0是通用方案</span></span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> max = nums[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果大于0，则证明 sum 尚有利用价值，可以继续利用之，因为 sum 加上正数会让 sum 更大</span></span><br><span class="line">    <span class="comment">// 如果小于0，则证明 sum 已无利用价值，因为 sum 加上负数只会让 sum 更小，会拖累整体的，只能含泪让 sum 从新开始</span></span><br><span class="line">    sum &gt; <span class="number">0</span> ? sum += nums[i] : sum = nums[i]</span><br><span class="line">    <span class="comment">// sum 负责加加加， max 负责大大大</span></span><br><span class="line">    <span class="comment">// 每次迭代，都始终让我们的 max 保持最大值，因为sum会有多个累加和，并不是加到最后就会是最大值</span></span><br><span class="line">    max = <span class="title class_">Math</span>.<span class="title function_">max</span>(sum, max)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>未完待续…</p><hr><blockquote><p>文章内容均来自<a href="https://leetcode.cn/">LeetCode</a>，仅供本人学习使用。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#无重复字符的最长子串&quot; class=&quot;headerlink&quot; title=&quot;无重复字符的最长子串&quot;&gt;&lt;/a&gt;无重复字符的最长子串&lt;/h3&gt;&lt;p&gt;难度：中等	频度：41&lt;/p&gt;
&lt;p&gt;题目：给定一个字符串 &lt;code&gt;s&lt;</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.cilicili.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://blog.cilicili.xyz/tags/JavaScript/"/>
    
    <category term="字节跳动" scheme="https://blog.cilicili.xyz/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"/>
    
    <category term="CodeTop" scheme="https://blog.cilicili.xyz/tags/CodeTop/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录—JS算法学习(一)</title>
    <link href="https://blog.cilicili.xyz/posts/4a17b157.html"/>
    <id>https://blog.cilicili.xyz/posts/4a17b157.html</id>
    <published>2022-07-13T16:00:00.000Z</published>
    <updated>2022-07-17T07:43:17.093Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong>概念：</strong>数组是存放在连续内存空间上的相同类型数据的集合。</p><blockquote><p><strong>Tips:</strong></p><ul><li><strong>数组下标都是从0开始的。</strong></li><li><strong>数组内存空间的地址是连续的</strong>。</li><li><strong>数组的元素是不能删的，只能覆盖。</strong></li></ul></blockquote><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>题目：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">12</span>], target = <span class="number">9</span>     </span><br><span class="line">输出: <span class="number">4</span>       </span><br><span class="line">解释: <span class="number">9</span> 出现在 nums 中并且下标为 <span class="number">4</span>   </span><br></pre></td></tr></table></figure><p>思路：<strong>这道题目的前提是数组为有序数组</strong>，同时题目还强调<strong>数组中无重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件。写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p><p>答案解析：</p><p><strong>① 定义 target 是在一个在左闭右闭的区间里，即[left, right]。</strong></p><p><strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p><ul><li>while (left &lt;&#x3D; right) 要使用 &lt;&#x3D; ，因为left &#x3D;&#x3D; right是有意义的，所以使用 &lt;&#x3D;</li><li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li></ul><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="comment">// right是数组最后一个数的下标，num[right]在查找范围内，是左闭右闭区间</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当left=right时，由于nums[right]在查找范围内，所以要包括此情况</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = left + <span class="title class_">Math</span>.<span class="title function_">floor</span>((right - left)/<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 如果中间数大于目标值，要把中间数排除查找范围，所以右边界更新为mid-1；如果右边界更新为mid，那中间数还在下次查找范围内</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;  <span class="comment">// 去左面闭区间寻找</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;   <span class="comment">// 去右面闭区间寻找</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>②  定义 target 是在一个在左闭右开的区间里，即[left, right)。</strong></p><p><strong>有如下两点：</strong></p><ul><li>while (left &lt; right)，这里使用 &lt; ,因为left &#x3D;&#x3D; right在区间[left, right)是没有意义的；</li><li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]；</li></ul><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="comment">// right是数组最后一个数的下标+1，nums[right]不在查找范围内，是左闭右开区间</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.<span class="property">length</span>;    </span><br><span class="line">    <span class="comment">// 当left=right时，由于nums[right]不在查找范围，所以不必包括此情况</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = left + <span class="title class_">Math</span>.<span class="title function_">floor</span>((right - left)/<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 如果中间值大于目标值，中间值不应在下次查找的范围内，但中间值的前一个值应在；</span></span><br><span class="line">        <span class="comment">// 由于right本来就不在查找范围内，所以将右边界更新为中间值，如果更新右边界为mid-1则将中间值的前一个值也踢出了下次寻找范围</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;  <span class="comment">// 去左区间寻找</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;   <span class="comment">// 去右区间寻找</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>相关题目推荐：</p><ul><li>35.搜索插入位置</li><li>34.在排序数组中查找元素的第一个和最后一个位置</li><li>69.x 的平方根</li><li>367.有效的完全平方数</li></ul></blockquote><h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><p>题目：给你一个数组nums和一个值val，你需要 <strong>原地</strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong>原地 修改输入数组</strong>。元素的顺序可以改变，你不需要考虑数组中超出新长度后面的元素。</p><p>示例：给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">removeElement</span> = (<span class="params">nums, val</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != val)&#123;</span><br><span class="line">            nums[k++] = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>相关题目推荐：</p><ul><li>26.删除排序数组中的重复项</li><li>283.移动零</li><li>844.比较含退格的字符串</li><li>977.有序数组的平方</li></ul></blockquote><h3 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h3><p>题目：给你一个按 <strong>非递减顺序</strong> 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><p>示例： 输入：nums &#x3D; [-7,-3,2,3,11] 输出：[4,9,9,49,121]。</p><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortedSquares = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="comment">// fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。</span></span><br><span class="line">    <span class="comment">// arr.fill(value[, start[, end]])。</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>, k = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">let</span> left = nums[i] * nums[i],</span><br><span class="line">            right = nums[j] * nums[j];</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            res[k--] = right;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[k--] = left;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="长度最小的子数组（滑动窗口法）"><a href="#长度最小的子数组（滑动窗口法）" class="headerlink" title="长度最小的子数组（滑动窗口法）"></a>长度最小的子数组（滑动窗口法）</h3><p>题目：给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><p>示例：输入：s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3] ；输出：2；解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="keyword">function</span>(<span class="params">target, nums</span>) &#123;</span><br><span class="line">    <span class="comment">// 长度计算一次</span></span><br><span class="line">    <span class="keyword">const</span> len = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> l = r = sum = <span class="number">0</span>, <span class="comment">// l,r分别为左右窗口,窗口中和大于等于target时缩短左窗，小于时扩大右窗。</span></span><br><span class="line">        res = len + <span class="number">1</span>; <span class="comment">// 子数组最大不会超过自身，res为最终结果</span></span><br><span class="line">    <span class="comment">// 扩大右窗口找到第一个满足的窗口</span></span><br><span class="line">    <span class="keyword">while</span>(r &lt; len) &#123;</span><br><span class="line">        sum += nums[r++];</span><br><span class="line">        <span class="comment">// 窗口滑动，缩短左窗口尝试找最小满足窗口</span></span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target) &#123;</span><br><span class="line">            <span class="comment">// r始终为开区间 [l, r)</span></span><br><span class="line">            res = res &lt; r - l ? res : r - l;</span><br><span class="line">            sum-=nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res &gt; len ? <span class="number">0</span> : res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li></ul><blockquote><p>主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操 作两次，所以时间复杂度是 2 × n 也就是O(n)。</p></blockquote><ul><li>空间复杂度：O(1)</li></ul><blockquote><p>相关题目推荐：</p><ul><li>904.水果成篮</li><li>76.最小覆盖子串</li></ul></blockquote><h3 id="螺旋矩阵II（模拟行为）"><a href="#螺旋矩阵II（模拟行为）" class="headerlink" title="螺旋矩阵II（模拟行为）"></a>螺旋矩阵II（模拟行为）</h3><p>题目：给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>示例：输入: 3；输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</p><p><img src= "/img/loading.gif" data-lazy-src="./images/loading.gif" data-original="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="力扣螺旋矩阵"></p><p>思路：求解本题依然是要坚持循环不变量原则。</p><blockquote><p>模拟顺时针画矩阵的过程:</p><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul></blockquote><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> generateMatrix = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> startX = startY = <span class="number">0</span>;   <span class="comment">// 起始位置</span></span><br><span class="line">    <span class="keyword">let</span> loop = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n/<span class="number">2</span>);   <span class="comment">// 旋转圈数</span></span><br><span class="line">    <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n/<span class="number">2</span>);    <span class="comment">// 中间位置</span></span><br><span class="line">    <span class="keyword">let</span> offset = <span class="number">1</span>;    <span class="comment">// 控制每一层填充元素个数</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">1</span>;     <span class="comment">// 更新填充数字</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (loop--) &#123;</span><br><span class="line">        <span class="keyword">let</span> row = startX, col = startY;</span><br><span class="line">        <span class="comment">// 上行从左到右（左闭右开）</span></span><br><span class="line">        <span class="keyword">for</span> (; col &lt; startY + n - offset; col++) &#123;</span><br><span class="line">            res[row][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右列从上到下（左闭右开）</span></span><br><span class="line">        <span class="keyword">for</span> (; row &lt; startX + n - offset; row++) &#123;</span><br><span class="line">            res[row][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下行从右到左（左闭右开）</span></span><br><span class="line">        <span class="keyword">for</span> (; col &gt; startY; col--) &#123;</span><br><span class="line">            res[row][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左列做下到上（左闭右开）</span></span><br><span class="line">        <span class="keyword">for</span> (; row &gt; startX; row--) &#123;</span><br><span class="line">            res[row][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新起始位置</span></span><br><span class="line">        startX++;</span><br><span class="line">        startY++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新offset</span></span><br><span class="line">        offset += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        res[mid][mid] = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>相似题目推荐：</p><ul><li>54.螺旋矩阵</li><li>29.顺时针打印矩阵（剑指Offer ）</li></ul></blockquote><hr><blockquote><p>文章内容均转载自<a href="https://programmercarl.com/">代码随想录</a>，仅供本人学习使用。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;概念：&lt;/strong&gt;数组是存放在连续内存空间上的相同类型数据的集合。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;stro</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.cilicili.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://blog.cilicili.xyz/tags/JavaScript/"/>
    
    <category term="代码随想录" scheme="https://blog.cilicili.xyz/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
</feed>
