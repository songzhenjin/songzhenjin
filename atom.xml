<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>研友.PinkPather_</title>
  
  
  <link href="https://blog.cilicili.xyz/atom.xml" rel="self"/>
  
  <link href="https://blog.cilicili.xyz/"/>
  <updated>2022-07-16T07:50:47.876Z</updated>
  <id>https://blog.cilicili.xyz/</id>
  
  <author>
    <name>研友.PinkPather_</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CodeTop字节跳动前端算法（一）</title>
    <link href="https://blog.cilicili.xyz/posts/4a17b158.html"/>
    <id>https://blog.cilicili.xyz/posts/4a17b158.html</id>
    <published>2022-07-14T16:00:00.000Z</published>
    <updated>2022-07-16T07:50:47.876Z</updated>
    
    <content type="html"><![CDATA[<h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h3><p>难度：中等频度：41</p><p>题目：给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;abc&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br></pre></td></tr></table></figure><p>1.思路：利用 <strong>数组</strong> 解法</p><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.<span class="property">length</span>;i++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(arr.<span class="title function_">includes</span>(s[i]))&#123;</span><br><span class="line">        arr.<span class="title function_">splice</span>(<span class="number">0</span>,arr.<span class="title function_">indexOf</span>(s[i])+<span class="number">1</span>)<span class="comment">//如果重复了就删除前面所有的字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    arr.<span class="title function_">push</span>(s[i])<span class="comment">//如果不重复就添加</span></span><br><span class="line">    res = <span class="title class_">Math</span>.<span class="title function_">max</span>(res,arr.<span class="property">length</span>)<span class="comment">//记录最长的长度</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res<span class="comment">//返回长度结果  利用数组还可以将完整的子串返回出来</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行用时：72ms </p><p>2.思路：<strong>滑动窗口法</strong></p><ul><li>用双指针维护一个滑动窗口，用来剪切子串。</li><li>不断移动右指针，直到遇到重复字符的时候把左指针移到前面的重复字符的下一位。</li><li>移动指针过程中，记录窗口长度的最大值即为答案。</li></ul><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">s</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> l=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> map=<span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> r=<span class="number">0</span>;r&lt;s.<span class="property">length</span>;r++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="title function_">has</span>(s[r])&amp;&amp;map.<span class="title function_">get</span>(s[r])&gt;=l)&#123;</span><br><span class="line">            l=map.<span class="title function_">get</span>(s[r])+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//console.log(s.slice(l,r+1))</span></span><br><span class="line">        res=<span class="title class_">Math</span>.<span class="title function_">max</span>(res,r-l+<span class="number">1</span>);</span><br><span class="line">        map.<span class="title function_">set</span>(s[r],r);</span><br><span class="line">        <span class="comment">//console.log(&quot;map&quot;,map)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">lengthOfLongestSubstring</span>(<span class="string">&quot;abbcdea&quot;</span>))</span><br></pre></td></tr></table></figure><p>执行用时：76ms</p><h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h3><p>难度：简单频度：26</p><p>题目：给你两个按 <strong>非递减顺序</strong> 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 <strong>合并</strong> nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p><strong>注意</strong>：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span>, nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>], n = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">解释：需要合并 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 和 [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>] 。</span><br><span class="line">合并结果是 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>] ，其中前两个为 nums1 中的元素。</span><br></pre></td></tr></table></figure><p>代码：</p><p>1.简单版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) &#123;</span><br><span class="line">    <span class="comment">// 将splice将nums2的值放到nums1的后面</span></span><br><span class="line">    <span class="comment">// 从m位置开始删除n个（nums2的长度）元素，然后将nums2添加到最后</span></span><br><span class="line">    nums1.<span class="title function_">splice</span>(m,n,...nums2);</span><br><span class="line">    <span class="comment">// 将nums1进行排序,修改的是原来的数组，所以不需要返回</span></span><br><span class="line">    nums1.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>(a-b)); <span class="comment">// sort((a,b)=&gt;(a-b))冒泡排序</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.<a href="%5Bhttps://leetcode-cn.com/problems/merge-sorted-array/solution/ni-xiang-shuang-zhi-zhen-he-bing-liang-g-ucgj/%5D()">逆双向指针</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置三个指针，分别指向nums1和nums2的数字部分的尾部 + nums1数组的尾部</span></span><br><span class="line">    <span class="keyword">var</span> i = m-<span class="number">1</span>,</span><br><span class="line">        j = n-<span class="number">1</span>,</span><br><span class="line">        k = m+n-<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 必须把所有的条件判断都写到一起，这样满足一个条件就会结束本次循环。不会继续往下执行。</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 其中一个数组不为空，就可以进行下面的循环</span></span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123; </span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// nums1为空的情况,将nums2的所有值放到nums1中</span></span><br><span class="line">            nums1[k--] = nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// nums2为空的情况,将nums1的所有值放到nums1中</span></span><br><span class="line">            nums1[k--] = nums1[i--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两者均不空的时候</span></span><br><span class="line">        <span class="comment">// 如果数组2中的数字大，就放到数组1的末尾.并且元素需要移动，所以需要自减操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">            nums1[k--] = nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 数组1中的数字大，就移动数组1中的数字到数组1的末尾</span></span><br><span class="line">            nums1[k--] = nums1[i--];   </span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="比较版本号"><a href="#比较版本号" class="headerlink" title="比较版本号"></a>比较版本号</h3><p>难度：中等频度：22</p><p>题目：给你两个版本号 <code>version1</code> 和 <code>version2</code> ，请你比较它们。</p><p>版本号由一个或多个修订号组成，各修订号由一个 <code>&#39;.&#39;</code> 连接。每个修订号由 <strong>多位数字</strong> 组成，可能包含 <strong>前导零</strong> 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，<code>2.5.33</code> 和 <code>0.1</code> 都是有效的版本号。</p><p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 <strong>忽略任何前导零后的整数值</strong> 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</p><p>返回规则如下：</p><p>如果 version1 &gt; version2 返回 1，<br>如果 version1 &lt; version2 返回 -1，<br>除此之外返回 0。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：version1 = <span class="string">&quot;1.01&quot;</span>, version2 = <span class="string">&quot;1.001&quot;</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：忽略前导零，<span class="string">&quot;01&quot;</span> 和 <span class="string">&quot;001&quot;</span> 都表示相同的整数 <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compareVersion = <span class="keyword">function</span>(<span class="params">version1, version2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> a = version1.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> b = version2.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> maxLength = <span class="title class_">Math</span>.<span class="title function_">max</span>(a.<span class="property">length</span>, b.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxLength; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> cur = a[i] || <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> next = b[i] || <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[i] === b[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">parseInt</span>(cur) &gt; <span class="built_in">parseInt</span>(next)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">parseInt</span>(cur) &lt; <span class="built_in">parseInt</span>(next)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h3><p>难度：简单频度：21</p><p>题目：给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <code>根节点到叶子节点</code> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> </p><p>示例：</p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="literal">null</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">1</span>], targetSum = <span class="number">22</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：等于目标和的根节点到叶节点路径如上图所示。</span><br></pre></td></tr></table></figure><p>思路：使用深度优先遍历的方式，递归左右子树，不断让sum减去当前节点的值。左右子树有一个返回true就找到了一条这样的路径<br>复杂度：时间复杂度O(n)，n是节点个数，每个节点遍历一次。空间复杂度O(n)，取决于递归栈空间，最坏的情况下是O(n)</p><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasPathSum = <span class="keyword">function</span>(<span class="params">root, sum</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 递归终止条件</span></span><br><span class="line">    sum-=root.<span class="property">val</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.<span class="property">left</span> === <span class="literal">null</span> &amp;&amp; root.<span class="property">right</span> === <span class="literal">null</span>) &#123; <span class="comment">// 遍历到叶子结点</span></span><br><span class="line">        <span class="keyword">return</span> sum === <span class="number">0</span>; <span class="comment">// sum正好减少到了0 返回ture 否则返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归左右子树，有一个返回true就找到了一条这样的路径</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">hasPathSum</span>(root.<span class="property">left</span>, sum) || <span class="title function_">hasPathSum</span>(root.<span class="property">right</span>, sum);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h3><p>难度：简单频度：20</p><p>题目：给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>​1.左括号必须用相同类型的右括号闭合。<br>    2.左括号必须以正确的顺序闭合。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;()&quot;</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> len=s.<span class="property">length</span>/<span class="number">2</span>; <span class="comment">// 如果字符串是奇数，则括号必定无法匹配</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        s= s.<span class="title function_">replace</span>(<span class="string">&quot;[]&quot;</span>,<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        s= s.<span class="title function_">replace</span>(<span class="string">&quot;()&quot;</span>,<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        s= s.<span class="title function_">replace</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="property">length</span>&gt;<span class="number">0</span> ?<span class="attr">false</span>:<span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最大的子数组合"><a href="#最大的子数组合" class="headerlink" title="最大的子数组合"></a>最大的子数组合</h3><p>难度：简单频度：20</p><p>题目：给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：连续子数组 [<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 的和最大，为 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="comment">// 0 为无，0 在累加类的算法计算中将不会对结果产生任何影响，所以初始化 sum 为0是通用方案</span></span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> max = nums[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果大于0，则证明 sum 尚有利用价值，可以继续利用之，因为 sum 加上正数会让 sum 更大</span></span><br><span class="line">    <span class="comment">// 如果小于0，则证明 sum 已无利用价值，因为 sum 加上负数只会让 sum 更小，会拖累整体的，只能含泪让 sum 从新开始</span></span><br><span class="line">    sum &gt; <span class="number">0</span> ? sum += nums[i] : sum = nums[i]</span><br><span class="line">    <span class="comment">// sum 负责加加加， max 负责大大大</span></span><br><span class="line">    <span class="comment">// 每次迭代，都始终让我们的 max 保持最大值，因为sum会有多个累加和，并不是加到最后就会是最大值</span></span><br><span class="line">    max = <span class="title class_">Math</span>.<span class="title function_">max</span>(sum, max)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>未完待续…</p><hr><blockquote><p>文章内容均来自<a href="https://leetcode.cn/">LeetCode</a>，仅供本人学习使用。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;无重复字符的最长子串&quot;&gt;&lt;a href=&quot;#无重复字符的最长子串&quot; class=&quot;headerlink&quot; title=&quot;无重复字符的最长子串&quot;&gt;&lt;/a&gt;无重复字符的最长子串&lt;/h3&gt;&lt;p&gt;难度：中等	频度：41&lt;/p&gt;
&lt;p&gt;题目：给定一个字符串 &lt;code&gt;s&lt;</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.cilicili.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://blog.cilicili.xyz/tags/JavaScript/"/>
    
    <category term="字节跳动" scheme="https://blog.cilicili.xyz/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"/>
    
    <category term="CodeTop" scheme="https://blog.cilicili.xyz/tags/CodeTop/"/>
    
  </entry>
  
  <entry>
    <title>HTML5经典面试题汇总</title>
    <link href="https://blog.cilicili.xyz/posts/4a17b156.html"/>
    <id>https://blog.cilicili.xyz/posts/4a17b156.html</id>
    <published>2022-07-14T01:25:00.000Z</published>
    <updated>2022-07-16T02:02:09.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高频重点"><a href="#高频重点" class="headerlink" title="高频重点"></a>高频重点</h2><h3 id="HTML语义化"><a href="#HTML语义化" class="headerlink" title="HTML语义化"></a>HTML语义化</h3><p><strong>非语义元素</strong>例子：<code>&lt;div&gt;</code>和<code>&lt;span&gt;</code></p><p><strong>语义元素</strong>例子：<code>form</code>、<code>table</code>、<code>&lt;nav&gt;</code> 和 <code>&lt;header&gt;</code>有明确定义其内容</p><p><strong>语义化的作用</strong>：</p><ul><li><strong>更好的内容结构：</strong>当页面在没有 CSS 的情况下也能呈现出很好地代码结构，易于阅读；</li><li><strong>提升用户体验</strong>，如 title、alt 属性用于名词解释或图片内容说明，以及 label 标签的灵活运用等；</li><li><strong>有利于<a href="https://zhuanlan.zhihu.com/p/210428775">SEO</a>优化</strong>，与搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重；</li><li><strong>可访问性</strong>：帮助屏幕阅读器等辅助技术更好的阅读和转译网页，利于无障碍阅读；</li><li><strong>国际化</strong>：遵循 W3C 标准通用的语义化标签可以让各国开发者更容易弄懂你网页的结构；</li><li><strong>可维护性</strong>：增强可读性，减少网页间的差异性，方便后期开发和维护；</li></ul><blockquote><p><strong>语义化时注意事项：</strong></p><ul><li>少使用无语义的标签 <code>div </code>和 <code>span</code>；</li><li>在语义不明显时，既可以使用 <code>div</code> 或者 <code>p</code> 时，尽量用 <code>p</code>, 因为 <code>p</code> 在默认情况下有上下间距，对兼容特殊终端有利；</li><li>不要使用纯样式标签，如：<code>b</code>、<code>font</code>、<code>u</code> 等，改用 css 设置；</li><li>需要强调的文本，可以包含在 <code>strong</code> 或 <code>em</code> 标签中，<code>strong</code> 默认样式是加粗（不要用 <code>b</code>），<code>em</code> 是斜体（不要用 <code>i</code> 标签）；</li><li>使用表格时，标题要用 <code>caption</code>，表头用 <code>thead</code>，主体部分用 <code>tbody</code> 包围，尾部用 <code>tfoot</code> 包围。表头和一般单元格要区分开，表头用 <code>th</code>，单元格用 <code>td</code>；</li><li>表单域要用 <code>fieldset</code> 标签包起来，并用 legend 标签说明表单的用途；</li><li>每个 <code>input</code> 标签对应的说明文本都需要使用 <code>label</code> 标签，并且通过为 <code>input</code> 设置 id 属性，在 lable 标签中设置 <code>for=someld</code> 来让说明文本和相对应的 <code>input</code> 关联起来；</li><li>不仅写 html 结构时，要用语义化标签，给元素写 css 类名时，JS 类名、方法名、变量命名等也要遵循语义化原则；不随意取名，不利于后期的代码重构和维护；同时，也最好不要用汉语拼音命名；</li></ul></blockquote><h3 id="HTML5新增的语义化标签"><a href="#HTML5新增的语义化标签" class="headerlink" title="HTML5新增的语义化标签"></a>HTML5新增的语义化标签</h3><table><thead><tr><th align="center"><strong>标签</strong></th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>&lt;header&gt;</code></td><td align="center">定义了文档的头部区域</td></tr><tr><td align="center"><code>&lt;nav&gt;</code></td><td align="center">定义导航链接的部分</td></tr><tr><td align="center"><code>&lt;main&gt;</code></td><td align="center">定义文档的主体内容</td></tr><tr><td align="center"><code>&lt;section&gt;</code></td><td align="center">定义文档中的节（section、区段）</td></tr><tr><td align="center"><code>&lt;article&gt;</code></td><td align="center">定义页面独立的内容区域</td></tr><tr><td align="center"><code>&lt;aside&gt;</code></td><td align="center">定义页面的侧边栏内容</td></tr><tr><td align="center"><code>&lt;details&gt;</code></td><td align="center">用于描述文档或文档某个部分的细节</td></tr><tr><td align="center"><code>&lt;figcaption&gt;</code></td><td align="center">定义 <code>&lt;figure&gt;</code> 元素的标题</td></tr><tr><td align="center"><code>&lt;figure&gt;</code></td><td align="center">规定独立的流内容（图像、图表、照片、代码等等）</td></tr><tr><td align="center"><code>&lt;summary&gt;</code></td><td align="center">标签包含 <code>details</code> 元素的标题</td></tr><tr><td align="center"><code>&lt;time&gt;</code></td><td align="center">定义日期或时间</td></tr><tr><td align="center"><code>&lt;footer&gt;</code></td><td align="center">定义 section 或 document 的页脚</td></tr></tbody></table><blockquote><p><a href="https://htmlreference.io/semantic/">简单用法</a></p></blockquote><h3 id="DOCTYPE-的作用和子属性（字节）"><a href="#DOCTYPE-的作用和子属性（字节）" class="headerlink" title="DOCTYPE 的作用和子属性（字节）"></a>DOCTYPE 的作用和子属性（字节）</h3><p>DOCTYPE 是 document type (文档类型) 的缩写。<code>&lt;!DOCTYPE&gt;</code>声明位于文档的最前面，处于标签之前，它不是 html 标签。主要作用是告诉浏览器的解析器使用哪种 HTML 规范或者 XHTML 规范来解析页面。</p><blockquote><p><strong>DOCTYPE 声明的目的是：</strong>防止浏览器在渲染文档时，进入“怪异模式”渲染。“<code>&lt;!DOCTYPE html&gt;</code>“ 确保浏览器按照标准模式进行渲染，而不是使用一个不符合规范的渲染模式。</p></blockquote><p><code>&lt;!DOCTYPE&gt;</code>的<strong>常见声明类型</strong>共有 8 种：</p><ul><li><p>其中 <strong>HTML5 有 1 种</strong>，<strong>HTML 4.01</strong> 和 <strong>XHTML 1.0 都有 3 种</strong>，<strong>XHTML 1.1 有 1 种</strong>；</p></li><li><p>在 HTML 4.01 中，&lt;!DOCTYPE&gt; 声明引用 DTD(<a href="https://www.w3.org/TR/html4/sgml/dtd.html">W3C 官方规范</a>)，因为 HTML 4.01 基于 SGML；DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容；</p></li><li><p>HTML5 不基于 SGML，所以不需要引用 DTD；</p></li></ul><blockquote><p>在 HTML5 中，只有一种可用的 DOCTYPE 声明</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span> </span><br></pre></td></tr></table></figure></blockquote><h4 id="DOCTYPE-与浏览器模式"><a href="#DOCTYPE-与浏览器模式" class="headerlink" title="DOCTYPE 与浏览器模式"></a><strong>DOCTYPE 与浏览器模式</strong></h4><p><strong>目前浏览器的排版引擎使用三种模式：</strong></p><ul><li>怪异模式（Quirks mode）：排版会模拟 Navigator 4 与 Internet Explorer 5 的非标准行为。在 W3C 标准出来之前，不同的浏览器对页面渲染有不同的标准，产生了一定的差异（也称之为混杂模式或兼容模式）；</li><li>接近标准模式（Almost standards mode）：只有少数的怪异行为被实现；</li><li>标准模式（Standards mode）：在 W3C 标准出来之后，浏览器对页面的渲染有了统一的标准，行为即按照 W3C 的标准来解析代码渲染页面；</li></ul><h4 id="DOCTYPE-声明与否的影响"><a href="#DOCTYPE-声明与否的影响" class="headerlink" title="DOCTYPE 声明与否的影响"></a><strong>DOCTYPE 声明与否的影响</strong></h4><p>如果有其他内容(空格除外) 或 不写文档 DOCTYPE 声明，浏览器将无法获知 HTML 或 XHTML 的文档类型，就会使浏览器进入怪异模式渲染网页，不同浏览器下，显示效果就会不一致。</p><blockquote><p><strong>DOCTYPE 对 HTML 标签的影响</strong></p><ul><li><code>&lt;article&gt;</code>和<code>&lt;aside&gt;</code>标签，能在 html5 中能使用，而在 HTML 4.01 和 XHTML 中就不能使用；</li><li><code>&lt;center&gt;</code>标签（目前 W3C 已废弃），XHTML1.0 版本中是不可用的，而在 HTML4.01 和 XHTML1.1 的<code>&lt;!DOCTYPE&gt;</code>声明中，只有 <code>Transitional</code> 和 <code>Frameset</code> 是可用的</li></ul></blockquote><h3 id="meta标签的作用和子属性"><a href="#meta标签的作用和子属性" class="headerlink" title="meta标签的作用和子属性"></a>meta标签的作用和子属性</h3><p><code>&lt;meta&gt;</code>标签用于描述 HTML 网页的元信息。</p><p>它不会显示在页面上，但是对于机器是可读的，并告诉机器该如何解析这个页面，如：浏览器（如何显示内容或重新加载页面），SEO 优化（keywords、description、robots）其他 web 服务等。</p><blockquote><p><strong>meta标签常用的属性</strong>：</p><table><thead><tr><th align="center">属性</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">charset</td><td align="center">规定 HTML 页面的字符编码常用的值：UTF-8(Unicode 字符编码)、 ISO-8859-1(拉 J 字母表的字符编码)</td></tr><tr><td align="center">content</td><td align="center">当 meta 标签中有<code>http-equiv</code>或<code>name</code>属性的时候，一定要有 content 属性对其进行说明。</td></tr><tr><td align="center">http-equiv</td><td align="center">添加 http 头部内容对一些自定义的，或者需要额外添加的 http 头部内容，需要发送到浏览器中，我们就可以是使用这个属性</td></tr><tr><td align="center">name</td><td align="center">元数据的名称<code>name</code> 和 <code>content</code> 属性可以一起使用，以<code>&quot;名 - 值&quot;</code>对的方式给文档提供元数据，content 作为元数据的值。</td></tr></tbody></table></blockquote><h3 id="HTML5的新特性"><a href="#HTML5的新特性" class="headerlink" title="HTML5的新特性"></a>HTML5的新特性</h3><p>新增的元素：</p><ul><li>语义化标签（header、nav、main、section、article、aside、details、figcaption、figure、mark、summary、time、footer 等）</li><li>Canvas 画布和 SVG 矢量图</li><li>拖放（Drag and drop）</li><li>音频、视频（audio、video）</li><li>地理定位（Geolocation）</li><li>本地离线存储（localStorage）长期存储数据，关闭浏览器后不丢失。</li><li>会话储存（sessionStorage）数据在关闭浏览器后自动删除。</li><li>表单控件（calendar、date、time、email、url、search）</li><li>新技术（Web Worker、Web Socket）</li><li>新的文档属性（document.visibilityState）</li></ul><p>删除的元素：</p><ul><li>纯表现的元素：basefont，big，center，font, s，strike，tt，u</li><li>对可用性产生负面影响的元素：frame，frameset，noframes</li></ul><h3 id="HTML的文件结构"><a href="#HTML的文件结构" class="headerlink" title="HTML的文件结构"></a>HTML的文件结构</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--声明当前文档类型为 html5标准--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--声明当前页面的语言类型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--网页的编码集--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--IE8及以上的版本按照最新的标准去渲染--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--用户移动端适配--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--网页标题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>艾编程<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--网页关键词--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;艾编程,WEB前端,Java架构师,Python课程&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--网页描述--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;为每个互联网人提供高质量的终身学习平台&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    ......</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Form表单的属性"><a href="#Form表单的属性" class="headerlink" title="Form表单的属性"></a>Form表单的属性</h3><ul><li>HTML 表单用于搜集不同类型的用户输入；</li><li>单纯的 form 标签没有任何作用，通过设置 <code>form</code> 标签的属性值以及为它添加子元素，从而达到上传数据以及和服务器进行通讯交互的目的；</li><li><code>&lt;form&gt;</code>标签的属性规定了当前网页上传数据的地址和方式。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span></span></span><br><span class="line"><span class="tag">      <span class="attr">action</span>=<span class="string">&quot;/user&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">method</span>=<span class="string">&quot;post&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">accept-charset</span>=<span class="string">&quot;UTF-8&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">ectype</span>=<span class="string">&quot;application/x-www-form-urlencoded&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">novalidate</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">      ......</span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">属性</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">action</td><td align="center">规定提交表单时将表单数据发送到何处，如果 action 的值为空或者#，则数据交由本页面处理。</td></tr><tr><td align="center">method</td><td align="center">method 即方法，规定发送表单数据时要使用的 HTTP 方法</td></tr><tr><td align="center">name</td><td align="center">Form 标签元素自身并没有数据传输，它的 name 属性只是提供了一种在脚本中引用表单的方法。对 form 进行标记，为 form 取个名字与此同时，form 标签元素内的数据都是通过 name 来传递的，只有设置了 name 属性的表单元素才能在提交表单时传递它们的值。</td></tr><tr><td align="center">accept-charset</td><td align="center">规定了服务器使用哪一种字符集编码来处理本页面所上传的数据。常用的有“UTF-8”、“ISO-8859-1”、”gb2312”等</td></tr><tr><td align="center">enctype</td><td align="center">规定在发送到服务器之前应该如何对表单数据进行编码① application&#x2F;x-www-form-urlencoded： 在发送前编码所有字符（默认值）把 “+” 转换为空格，并且把特殊字符转换为 ASCII 十六进制值。在不涉及文件传输时，一般使用这种方式；② multipart&#x2F;form-data： 不对字符编码，在使用包含文件上传控件的表单时（如：文档，图片、视频、MP3 等）必须使用该值；③ text&#x2F;plain：将内容设置为纯文本的形式，空格转换为 “+” 加号，但不对特殊字符编码；</td></tr><tr><td align="center">target</td><td align="center">target 属性规定在何处打开 action URL① _blank 在新窗口中打开② _self 默认，在相同的框架中打开③ _parent 在父框架集中打开④ _top 在整个窗口中打开⑤ framename 在指定的框架中打开</td></tr><tr><td align="center">autocomplete</td><td align="center">① 规定浏览器应该自动完成表单（默认：开启）当用户在字段开始键入时，浏览器基于之前键入过的值，显示出在 ② 该字段中填写过的选项，从而简化用户的输入③ autocomplete 只有两个值，on 和 off，分别对应启用和关闭这个功能。默认值为 on</td></tr><tr><td align="center">novalidate</td><td align="center">规定当提交表单时不对其进行验证通过将 novalidate&#x3D;novalidate 属性放置到 form 元素上，form 元素的原生校验特征就会忽略，这样就可以防止它同 JavaScript 的校验方法起冲突</td></tr></tbody></table><h3 id="href和src的区别"><a href="#href和src的区别" class="headerlink" title="href和src的区别"></a>href和src的区别</h3><p>href 用于建立当前页面与引用资源之间的关系，而 src 会替换当前元素。</p><p>遇到 href页面会并行加载后续内容，而 src 则需要浏览器加载完毕 src 的内容才会继续往下走。</p><p><strong>src 是 source 的缩写，指向外部资源的位置</strong></p><ul><li>指向的内容将会嵌入到文档中当前标签所在位置或下载并应用到文档内，如 js 脚本，img 图片和 iframe 等元素。</li><li>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将 js 脚本放在底部而不是头部。</li></ul><p><strong>href 是 Hypertext Reference 的缩写，指向网络资源所在位置</strong></p><ul><li>建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加<code>&lt;link href=&quot;common.css&quot; rel=&quot;stylesheet&quot;/&gt;</code>那么浏览器会识别该文档为 css 文件，然后并行下载资源并且不会停止对当前文档的处理。</li><li>这也是为什么建议使用 link 方式来加载 css，而不是使用@import 方式。</li></ul><h3 id="script-标签放在-head-里怎么解决加载问题"><a href="#script-标签放在-head-里怎么解决加载问题" class="headerlink" title="script 标签放在 head 里怎么解决加载问题"></a>script 标签放在 head 里怎么解决加载问题</h3><p>考点：主要涉及加载顺序、JS是单线程</p><blockquote><p>由于浏览器解析是自上而下加载解析，如果一个很大的 js 文件放在 head 里面，由于 js 是单线程，那么浏览器会一直解析中，而无法加载解析后面的 DOM tree，会阻塞后续的 DOM 渲染，以至于页面出现空白。</p></blockquote><p><strong>当浏览器加载一个含有<code>&lt;script&gt;</code>的页面时，会发生以下动作：</strong></p><ol><li>获取 HTML 文件，拉取 HTML 页面（如：index.html）</li><li>开始解析 html 文件</li><li>当解析器遇到一个<code>&lt;script&gt;</code>标签时，准备获取<code>&lt;script&gt;</code>标签对应的 js 文件</li><li>当解析器获取 js 文件时，同时阻塞了页面上其他 html 的解析（页面会出现空白，用户体验不好）</li><li>当 js 文件解析完毕，页面上其他的 html 标签继续解析</li></ol><blockquote><p><strong>阻塞 HTML 解析的原因：</strong></p><p>任何 script 代码都能改变 HTML 的结构，通过 document.write() 这种方式或者其他方式； 这就导致了 HTML 解析必须等待<code>&lt;script&gt;</code>全部被下载和执行完，HTML 才能解析 script 标签之后余下的部分；最后，用户才能看到具体页面。</p><blockquote><p><strong>早年的解决方式</strong></p><ul><li>以前解决这个问题的方式是将<code>&lt;script&gt;</code>标签放在 html 文件的<code>&lt;body&gt;</code>标签结束之前来执行；但这种加载方式存在的问题就是只有当所有的 html 元素加载完成后才能开始加载<code>&lt;script&gt;</code>标签的内容，如果这个加载需要花很长时间的话，那在这段时间内，就无法操作页面，要知道两秒之内不能操作页面的话，这个用户体验是非常差的；</li><li>如果 js 放在 head 里面，引用了某个 dom，但是这时你还没加载 dom tree，会报错，可以采用<code>window.onload = function()&#123;&#125;</code>这样来解决，但这任然不是最优解；</li><li>动态创建 DOM 方式，将 JS 代码放置在 body 标签结束之前；</li><li>使用 jQuery 的 <code>getScript()</code>方法；</li><li>使用<code>setTimeout</code>延迟方法；</li></ul></blockquote><blockquote><p><strong>目前各大厂主流的解决方案</strong></p><ul><li>现在浏览器和<code>&lt;script&gt;</code>标签都支持 <code>async</code> 和 <code>defer</code> 两个属性来解决 DOM 渲染阻塞的问题，这也是 script 标签非常重要的两个属性；</li><li>按需异步载入 js。</li></ul><ol><li><p><strong>当使用async时</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）；对 async 而言，脚本的加载和执行是紧挨着的，不管声明顺序如何，只要加载完就会立即执行。</li><li>async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：百度统计，Google Analytics 等</li></ul></li><li><p><strong>当使用defer时</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 推迟的脚本原则上按照它们被列出的顺序执行。</li></ul></li></ol><p><strong>两者之间共同点：</strong>defer 和 async 在网络读取（下载）这一阶段是一样的，相对于 html 解析来说都是异步的。<br><strong>两者之间差别是：</strong> script 脚本下载完后何时执行，defer 是最接近我们对于应用脚本加载和执行要求的。</p><p><strong>推荐实际应用场景：</strong></p><p>① 使用 async 属性：</p><ul><li>如果你的脚本并不关心页面中的 DOM 元素（文档是否解析完毕），并且也不会产生其他脚本需要的数据。如：百度统计，Google 统计等。</li></ul><p>② 使用defer属性：</p><ul><li>如果脚本代码依赖于页面中的 DOM 元素（文档是否解析完毕），或者被其他脚本文件依赖， 如：评论，代码语法高亮 等</li></ul></blockquote></blockquote><h3 id="不同图片格式的区别"><a href="#不同图片格式的区别" class="headerlink" title="不同图片格式的区别"></a>不同图片格式的区别</h3><p><strong>格式名：</strong></p><ul><li>gif，全称：图像互换格式（Graphics Interchange Format）是一种位图文件格式，以 8 位色重现真色彩的图像。可以实现动画效果；</li><li>jpg，全称：联合照片专家组（Joint Photographic Expert Group）简称：JPEG，jpg &#x3D;&#x3D;&#x3D; jpeg；<ul><li>是一种针对相片使用的一种失真压缩方法，是一种破坏性的压缩，在色调及颜色平滑变化做的不错。在 www 上，被用来储存和传输照片的格式。</li></ul></li><li>png，全称：便携式网络图形（Portable Network Graphics）是一种无损数据压缩位图文件格式；</li><li>webp 格式，谷歌（google）2010 年开发的一种旨在加快图片加载速度的图片格式。压缩率只有 jpg 的 2&#x2F;3，大小比 png 小了 45%，并能节省大量的服务器宽带资源和数据空间；</li><li>svg，全称：可缩放矢量图形（Scalable Vector Graphics）简称 SVG；<ul><li>它是基于 XML，由万维网联盟进行开发的。一种开放标准的矢量图形语言，可任意放大图形显示，边缘异常清晰，文字在 SVG 图像中保留可编辑和可搜寻的状态，没有字体的限制，生成的文件很小，下载很快，十分适合用于设计高分辨率的 Web 图形页面</li></ul></li></ul><table><thead><tr><th align="center">格式</th><th align="center">优点</th><th align="center">缺点</th><th align="center">适用场景</th></tr></thead><tbody><tr><td align="center">gif</td><td align="center">支持动画、透明，无兼容性问题</td><td align="center">仅布尔透明</td><td align="center">色彩简单的 logo、icon、动图</td></tr><tr><td align="center">jpg</td><td align="center">色彩丰富，文件小</td><td align="center">有损压缩，反复保存图片质量下降明显</td><td align="center">色彩丰富的图片&#x2F;渐变图像，照片，复杂 banner</td></tr><tr><td align="center">png</td><td align="center">无损压缩，支持透明，简单图片尺寸小，高保真</td><td align="center">① 不支持动画，色彩丰富的图片尺寸大；② 对自然照片和复杂色块的图片压缩率不高</td><td align="center">logo&#x2F;icon&#x2F;透明图，适用于 web 所有场景</td></tr><tr><td align="center">webp</td><td align="center">文件小，支持有损和无损压缩，支持动画、透明</td><td align="center">浏览器兼容性相对而言不好</td><td align="center">支持 webp 格式的 app 和 webview，产品图片（如：京东）</td></tr><tr><td align="center">SVG</td><td align="center">① 可伸缩性，矢量图片随意放大缩小，不影响质量；显示效果好，不存在锯齿等情况② 体积小，Svg 平均比 GIF、 JPEG、 PNG 小得多，甚至在极高的分辨率下也是如此；③ 支持动画，更灵活、质量效果好；④ 与 DOM 无缝衔接，Svg 可以直接使用 HTML、 CSS 和 JavaScript （例如动画）来操作</td><td align="center">① 不适合高复杂度的图形，SVG 复杂度高会减慢渲染速度；② 不适合游戏类等高互动动画</td><td align="center">图表（echarts），图标，logo</td></tr></tbody></table><p><strong>常用图片格式PNG, GIF, JPG 比较</strong></p><table><thead><tr><th align="center">对比</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">大小</td><td align="center">PNG ≈ JPG &gt; GIF ，8 位的 PNG 完全可以替代掉 GIF</td></tr><tr><td align="center">透明性</td><td align="center">PNG &gt; GIF &gt; JPG</td></tr><tr><td align="center">色彩丰富程度</td><td align="center">JPG &gt; PNG &gt; GIF</td></tr><tr><td align="center">兼容程度</td><td align="center">GIF ≈ JPG &gt; PNG</td></tr></tbody></table><h3 id="精灵图的原理和优缺点？"><a href="#精灵图的原理和优缺点？" class="headerlink" title="精灵图的原理和优缺点？"></a>精灵图的原理和优缺点？</h3><p>精灵图是为了减少网络请求，将小图标和背景图像合并到一张图片上，然后利用 css 的 background-positon 或者 img 的 clip 来进行背景定位显示需要显示的图片部分</p><ul><li><strong>优点：</strong>减少加载网页图片时对服务器的请求次数，从而大大的提高页面的性能，减少图片的字节；</li><li><strong>缺点：</strong>使用起来不够灵活，标签更复杂如果需要多个尺寸，维护困难；</li><li><strong>适用场景：</strong>图标</li></ul><h3 id="Canvas的理解"><a href="#Canvas的理解" class="headerlink" title="Canvas的理解"></a>Canvas的理解</h3><p>Canvas 是画布，通过 Javascript 来绘制 2D 图形，是逐像素进行渲染的。一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。</p><blockquote><p>也是 HTML5 元素中功能最强大的一个，这种强大的能力是通过 canvas 的 context 对象表现出来的。它提供一套完整的绘图功能，从而使我们可以使用 javascript 可以操作他们。</p></blockquote><p><strong>canvas的特点：</strong></p><ul><li>依赖分辨率</li><li>逐像素进行渲染</li><li>弱的文本渲染能力</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>能够以 .png 或 .jpg 格式保存结果图像</li><li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li></ul><p><strong>canvas的常见作用：</strong></p><ul><li>游戏：相比 flash 技术，html5 基于 web 的图像显示更加立体，精巧。流行的游戏引擎 cocos2d-js、Egret 都基于 html5 的 canvas；</li><li>图表制作：图表制作时常被人们忽略，但无论企业内部还是企业间交流合作都离不开图表。现在一些开发者使用 HTML&#x2F;CSS 完成图标制作，完全可以用 Canvas 来实现。当然，使用 SVG(可缩放矢量图形)来完成图表制作也是非常好的方法。</li><li>banner 广告：Flash 曾经辉煌的时代，智能手机还未曾出现。现在以及未来的智能机时代，HTML5 技术能够在 banner 广告上发挥巨大作用，用 Canvas 实现动态的广告效果再合适不过。</li><li>模拟器：无论从视觉效果还是核心功能方面来说，模拟器产品可以完全由 JavaScript 来实现。</li><li>远程计算机控制：Canvas 可以让开发者更好地实现基于 Web 的数据传输，构建一个完美的可视化控制界面。</li><li>字体设计：对于字体的自定义渲染将完全可以基于 Web，使用 HTML5 技术进行实现。</li><li>图形编辑器：图形编辑器将能够 100%基于 Web 实现。</li><li>其他可嵌入网站的内容：类似图表、音频、视频,还有许多元素能够更好地与 Web 融合，并且不需要任何插件。继续挖掘 Canvas 的潜力，运用 HTML5 技术创造更多价值。</li></ul><h3 id="“-data-”-属性的作用"><a href="#“-data-”-属性的作用" class="headerlink" title="“ data- *” 属性的作用"></a>“ data- *” 属性的作用</h3><p>“data-*” 是 HTML5 新增的自定义属性，用于存储页面或应用程序的私有自定义数据。</p><p><strong>优点：</strong>存储的（自定义）数据能够被页面的 JavaScript 中利用，以创建更好的用户体验（不进行 Ajax 调用或服务器端数据库查询）</p><p><strong>data-* 属性包括两部分：</strong></p><ul><li>属性名<strong>不应该包含任何大写字母</strong>，并且在前缀 “data-“ 之后必须有至少一个字符，多个单词组成需用连字符分割，如：“data-color” 或 “data-list-name”；</li><li>属性值可以是任意字符串；</li></ul><p><strong>使用方法：</strong></p><p>这些属性集可以通过对象的<code>dataset</code>属性获取，不支持该属性的浏览器可以通过<code>getAttribute</code>方法获取。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;animal&quot;</span> <span class="attr">data-type</span>=<span class="string">&quot;cat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;people&quot;</span> <span class="attr">data-type-name</span>=<span class="string">&quot;arry老师&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> animal = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;animal&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> people = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;people&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 使用 dataset属性赋值</span></span></span><br><span class="line"><span class="language-javascript">  animal.<span class="property">dataset</span>.<span class="property">type</span> = <span class="string">&quot;sheep&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 使用 dataset属性取值</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(animal.<span class="property">dataset</span>.<span class="property">type</span>); <span class="comment">// sheep</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 如果是 data-abc-abc-abc 的格式，则采用首字母小写的驼峰式 abcAbcAbc 读写该自定义属性值</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// data多个连字符赋值</span></span></span><br><span class="line"><span class="language-javascript">  people.<span class="property">dataset</span>.<span class="property">typeName</span> = <span class="string">&quot;清心老师&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// data多个连字符取值</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(people.<span class="property">dataset</span>.<span class="property">typeName</span>); <span class="comment">// 清心老师</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 使用setAttribute 给data属性赋值</span></span></span><br><span class="line"><span class="language-javascript">  animal.<span class="title function_">setAttribute</span>(<span class="string">&quot;data-type&quot;</span>, <span class="string">&quot;dog&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 使用getAttribute取值</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(animal.<span class="title function_">getAttribute</span>(<span class="string">&quot;data-type&quot;</span>)); <span class="comment">// dog</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 如果是 data-abc-abc-abc 的格式，则采用首字母小写的驼峰式 abcAbcAbc 读写该自定义属性值</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// setAttribute多个连字符赋值</span></span></span><br><span class="line"><span class="language-javascript">  people.<span class="title function_">setAttribute</span>(<span class="string">&quot;typeName&quot;</span>, <span class="string">&quot;allen老师&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// getAttribute多个连字符取值</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(people.<span class="title function_">getAttribute</span>(<span class="string">&quot;typeName&quot;</span>)); <span class="comment">// allen老师</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// jQuery中使用</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 设置data属性： $(&quot;元素&quot;).attr(&quot;key&quot;,&quot;value&quot;)或 $(&quot;元素&quot;).data(&quot;key&quot;,&quot;value&quot;) 即可</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="HTML-x2F-HTML5基础"><a href="#HTML-x2F-HTML5基础" class="headerlink" title="HTML&#x2F;HTML5基础"></a>HTML&#x2F;HTML5基础</h2><h3 id="canvas和svg有什么区别？"><a href="#canvas和svg有什么区别？" class="headerlink" title="canvas和svg有什么区别？"></a>canvas和svg有什么区别？</h3><table><thead><tr><th align="center">Canvas</th><th align="center">SVG</th></tr></thead><tbody><tr><td align="center">它是通过 JavaScript 来绘制的</td><td align="center">使用 XML 的 2d 语言</td></tr><tr><td align="center">取决于分辨率（依赖）</td><td align="center">独立于分辨率（不依赖）</td></tr><tr><td align="center">不支持事件处理程序</td><td align="center">支持事件处理程序</td></tr><tr><td align="center">适用于小规模渲染应用程序</td><td align="center">在大规模渲染应用程序中表现更好</td></tr><tr><td align="center">最适合图像密集型的游戏，其中的许多对象会被频繁重绘</td><td align="center">不适合游戏应用，复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</td></tr></tbody></table><blockquote><p><strong>适用范围：</strong></p><ul><li>Canvas 是逐像素进行渲染的，一旦图形绘制完成，就不会继续被浏览器关注。而 SVG 是通过 DOM 操作来显示的。</li><li>所以 Canvas 的文本渲染能力弱，而 SVG 最适合带有大型渲染区域的应用程序。</li><li>Canvas 最适合有许多对象要被频繁重绘的图形密集型游戏。</li><li>SVG 由于 DOM 操作 在复杂度高的游戏应用中 会减慢渲染速度。所以不适合在游戏应用。</li></ul></blockquote><h3 id="HTML-中的-void-元素是什么-？"><a href="#HTML-中的-void-元素是什么-？" class="headerlink" title="HTML 中的 void 元素是什么 ？"></a>HTML 中的 void 元素是什么 ？</h3><p>没有关闭标签或不需要关闭的<code>HTML元素</code>是<code>Void元素</code>。</p><p>例如 <code>&lt;br /&gt;</code>、<code>&lt;img /&gt;</code>、<code>&lt;hr /&gt;</code> 等。</p><h3 id="HTML5-与之前的版本相比有哪些优势-？"><a href="#HTML5-与之前的版本相比有哪些优势-？" class="headerlink" title="HTML5 与之前的版本相比有哪些优势 ？"></a>HTML5 与之前的版本相比有哪些优势 ？</h3><p><strong>HTML5 的优点</strong>：</p><ul><li>它有多媒体支持。</li><li>它具有使用 SQL 数据库和应用程序缓存存储离线数据的能力。</li><li>Javascript 可以在后台运行。</li><li>HTML5 还允许用户绘制各种形状，如矩形、圆形、三角形等。</li><li>包括新的语义标签和表单控制标签。</li></ul><h3 id="HTML5-规范的重要目标是什么-？"><a href="#HTML5-规范的重要目标是什么-？" class="headerlink" title="HTML5 规范的重要目标是什么 ？"></a>HTML5 规范的重要目标是什么 ？</h3><ul><li>引入新元素标签以更好地构建网页，例如 <code>&lt;header&gt;</code> 标签；</li><li>形成跨浏览器行为的标准并支持不同的设备和平台；</li><li>向后兼容旧版本的 HTML 网页；</li><li>引入基本交互元素，不依赖 <code>&lt;video&gt;</code> 标签等插件，而不是 flash 插件。</li></ul><h3 id="旧浏览器如何支持-SVG？"><a href="#旧浏览器如何支持-SVG？" class="headerlink" title="旧浏览器如何支持 SVG？"></a>旧浏览器如何支持 SVG？</h3><ul><li>为了支持旧浏览器而不是在 <code>&lt;img&gt;</code> 标签的 src 属性中定义 svg 的资源</li><li>应该在 <code>srcset</code> 属性中定义它，并且应该在 src 中定义备用 png 文件。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;circle.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;circle&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;circle.svg&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="HTML5-中的内联元素和块级元素分别有哪些"><a href="#HTML5-中的内联元素和块级元素分别有哪些" class="headerlink" title="HTML5 中的内联元素和块级元素分别有哪些 ?"></a>HTML5 中的内联元素和块级元素分别有哪些 ?</h3><p><strong>Inline 内联元素：</strong>内联元素只占用内容绝对必要的空间，而不是从新行开始，如：<code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;button&gt;</code>、<code>&lt;em&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;abbr&gt;</code>、<code>&lt;label&gt;</code>、<code>&lt;sub&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;abbr&gt;</code> 、<code>&lt;script&gt;</code>、<code>&lt;label&gt;</code>、<code>&lt;i&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;output&gt;</code>、<code>&lt;q&gt;</code> 等。</p><p><strong>Block块级元素：</strong>块元素从新行开始并占用可用页面的整个宽度，如<code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;header&gt;</code>、<code>&lt;footer&gt;</code>、<code>&lt;h1&gt;...&lt;h6&gt;</code>、<code>&lt;form&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;canvas&gt;</code>、<code>&lt;video&gt;</code>、<code>&lt;blockquote&gt;</code>、<code>&lt; pre&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;figcaption&gt;</code>、<code>&lt;figure&gt;</code>、<code>&lt;hr&gt;</code>、<code>&lt;article&gt;</code>、<code>&lt;section&gt;</code>等。</p><hr><blockquote><p>本篇文章均转载自arry老师的<a href="https://www.arryblog.com/interview/htmlcss/html-html5.html#%E9%AB%98%E9%A2%91%E9%87%8D%E7%82%B9">教程</a>，仅供本人学习使用。</p></blockquote>]]></content>
    
    
    <summary type="html">工作能力 ≠ 面试能力，面试之前刻意练习，强化训练。聚焦前端面试必考的刚需内容，掌握解决面试题的思路、技巧与方法论。持续更新 ......</summary>
    
    
    
    <category term="前端" scheme="https://blog.cilicili.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="HTML5" scheme="https://blog.cilicili.xyz/tags/HTML5/"/>
    
    <category term="面试题" scheme="https://blog.cilicili.xyz/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录—JS算法学习(一)</title>
    <link href="https://blog.cilicili.xyz/posts/4a17b157.html"/>
    <id>https://blog.cilicili.xyz/posts/4a17b157.html</id>
    <published>2022-07-13T16:00:00.000Z</published>
    <updated>2022-07-16T07:50:55.218Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong>概念：</strong>数组是存放在连续内存空间上的相同类型数据的集合。</p><blockquote><p><strong>Tips:</strong></p><ul><li><strong>数组下标都是从0开始的。</strong></li><li><strong>数组内存空间的地址是连续的</strong>。</li><li><strong>数组的元素是不能删的，只能覆盖。</strong></li></ul></blockquote><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>题目：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">12</span>], target = <span class="number">9</span>     </span><br><span class="line">输出: <span class="number">4</span>       </span><br><span class="line">解释: <span class="number">9</span> 出现在 nums 中并且下标为 <span class="number">4</span>   </span><br></pre></td></tr></table></figure><p>思路：<strong>这道题目的前提是数组为有序数组</strong>，同时题目还强调<strong>数组中无重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件。写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p><p>答案解析：</p><p><strong>① 定义 target 是在一个在左闭右闭的区间里，即[left, right]。</strong></p><p><strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p><ul><li>while (left &lt;&#x3D; right) 要使用 &lt;&#x3D; ，因为left &#x3D;&#x3D; right是有意义的，所以使用 &lt;&#x3D;</li><li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li></ul><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="comment">// right是数组最后一个数的下标，num[right]在查找范围内，是左闭右闭区间</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 当left=right时，由于nums[right]在查找范围内，所以要包括此情况</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = left + <span class="title class_">Math</span>.<span class="title function_">floor</span>((right - left)/<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 如果中间数大于目标值，要把中间数排除查找范围，所以右边界更新为mid-1；如果右边界更新为mid，那中间数还在下次查找范围内</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;  <span class="comment">// 去左面闭区间寻找</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;   <span class="comment">// 去右面闭区间寻找</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>②  定义 target 是在一个在左闭右开的区间里，即[left, right)。</strong></p><p><strong>有如下两点：</strong></p><ul><li>while (left &lt; right)，这里使用 &lt; ,因为left &#x3D;&#x3D; right在区间[left, right)是没有意义的；</li><li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]；</li></ul><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="comment">// right是数组最后一个数的下标+1，nums[right]不在查找范围内，是左闭右开区间</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.<span class="property">length</span>;    </span><br><span class="line">    <span class="comment">// 当left=right时，由于nums[right]不在查找范围，所以不必包括此情况</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = left + <span class="title class_">Math</span>.<span class="title function_">floor</span>((right - left)/<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 如果中间值大于目标值，中间值不应在下次查找的范围内，但中间值的前一个值应在；</span></span><br><span class="line">        <span class="comment">// 由于right本来就不在查找范围内，所以将右边界更新为中间值，如果更新右边界为mid-1则将中间值的前一个值也踢出了下次寻找范围</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;  <span class="comment">// 去左区间寻找</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;   <span class="comment">// 去右区间寻找</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>相关题目推荐：</p><ul><li>35.搜索插入位置</li><li>34.在排序数组中查找元素的第一个和最后一个位置</li><li>69.x 的平方根</li><li>367.有效的完全平方数</li></ul></blockquote><h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><p>题目：给你一个数组nums和一个值val，你需要 <strong>原地</strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong>原地 修改输入数组</strong>。元素的顺序可以改变，你不需要考虑数组中超出新长度后面的元素。</p><p>示例：给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">removeElement</span> = (<span class="params">nums, val</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != val)&#123;</span><br><span class="line">            nums[k++] = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>相关题目推荐：</p><ul><li>26.删除排序数组中的重复项</li><li>283.移动零</li><li>844.比较含退格的字符串</li><li>977.有序数组的平方</li></ul></blockquote><h3 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h3><p>题目：给你一个按 <strong>非递减顺序</strong> 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><p>示例： 输入：nums &#x3D; [-7,-3,2,3,11] 输出：[4,9,9,49,121]。</p><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortedSquares = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="comment">// fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。</span></span><br><span class="line">    <span class="comment">// arr.fill(value[, start[, end]])。</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>, k = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">let</span> left = nums[i] * nums[i],</span><br><span class="line">            right = nums[j] * nums[j];</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            res[k--] = right;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[k--] = left;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="长度最小的子数组（滑动窗口法）"><a href="#长度最小的子数组（滑动窗口法）" class="headerlink" title="长度最小的子数组（滑动窗口法）"></a>长度最小的子数组（滑动窗口法）</h3><p>题目：给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><p>示例：输入：s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3] ；输出：2；解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="keyword">function</span>(<span class="params">target, nums</span>) &#123;</span><br><span class="line">    <span class="comment">// 长度计算一次</span></span><br><span class="line">    <span class="keyword">const</span> len = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> l = r = sum = <span class="number">0</span>, <span class="comment">// l,r分别为左右窗口,窗口中和大于等于target时缩短左窗，小于时扩大右窗。</span></span><br><span class="line">        res = len + <span class="number">1</span>; <span class="comment">// 子数组最大不会超过自身，res为最终结果</span></span><br><span class="line">    <span class="comment">// 扩大右窗口找到第一个满足的窗口</span></span><br><span class="line">    <span class="keyword">while</span>(r &lt; len) &#123;</span><br><span class="line">        sum += nums[r++];</span><br><span class="line">        <span class="comment">// 窗口滑动，缩短左窗口尝试找最小满足窗口</span></span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target) &#123;</span><br><span class="line">            <span class="comment">// r始终为开区间 [l, r)</span></span><br><span class="line">            res = res &lt; r - l ? res : r - l;</span><br><span class="line">            sum-=nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res &gt; len ? <span class="number">0</span> : res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li></ul><blockquote><p>主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操 作两次，所以时间复杂度是 2 × n 也就是O(n)。</p></blockquote><ul><li>空间复杂度：O(1)</li></ul><blockquote><p>相关题目推荐：</p><ul><li>904.水果成篮</li><li>76.最小覆盖子串</li></ul></blockquote><h3 id="螺旋矩阵II（模拟行为）"><a href="#螺旋矩阵II（模拟行为）" class="headerlink" title="螺旋矩阵II（模拟行为）"></a>螺旋矩阵II（模拟行为）</h3><p>题目：给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>示例：输入: 3；输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="力扣螺旋矩阵"></p><p>思路：求解本题依然是要坚持循环不变量原则。</p><blockquote><p>模拟顺时针画矩阵的过程:</p><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul></blockquote><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> generateMatrix = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> startX = startY = <span class="number">0</span>;   <span class="comment">// 起始位置</span></span><br><span class="line">    <span class="keyword">let</span> loop = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n/<span class="number">2</span>);   <span class="comment">// 旋转圈数</span></span><br><span class="line">    <span class="keyword">let</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>(n/<span class="number">2</span>);    <span class="comment">// 中间位置</span></span><br><span class="line">    <span class="keyword">let</span> offset = <span class="number">1</span>;    <span class="comment">// 控制每一层填充元素个数</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">1</span>;     <span class="comment">// 更新填充数字</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (loop--) &#123;</span><br><span class="line">        <span class="keyword">let</span> row = startX, col = startY;</span><br><span class="line">        <span class="comment">// 上行从左到右（左闭右开）</span></span><br><span class="line">        <span class="keyword">for</span> (; col &lt; startY + n - offset; col++) &#123;</span><br><span class="line">            res[row][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右列从上到下（左闭右开）</span></span><br><span class="line">        <span class="keyword">for</span> (; row &lt; startX + n - offset; row++) &#123;</span><br><span class="line">            res[row][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下行从右到左（左闭右开）</span></span><br><span class="line">        <span class="keyword">for</span> (; col &gt; startY; col--) &#123;</span><br><span class="line">            res[row][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左列做下到上（左闭右开）</span></span><br><span class="line">        <span class="keyword">for</span> (; row &gt; startX; row--) &#123;</span><br><span class="line">            res[row][col] = count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新起始位置</span></span><br><span class="line">        startX++;</span><br><span class="line">        startY++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新offset</span></span><br><span class="line">        offset += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        res[mid][mid] = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>相似题目推荐：</p><ul><li>54.螺旋矩阵</li><li>29.顺时针打印矩阵（剑指Offer ）</li></ul></blockquote><hr><blockquote><p>文章内容均转载自<a href="https://programmercarl.com/">代码随想录</a>，仅供本人学习使用。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;概念：&lt;/strong&gt;数组是存放在连续内存空间上的相同类型数据的集合。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;stro</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.cilicili.xyz/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://blog.cilicili.xyz/tags/JavaScript/"/>
    
    <category term="代码随想录" scheme="https://blog.cilicili.xyz/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
  </entry>
  
</feed>
